package org.usfirst.frc.team321.autonomous;


import org.usfirst.frc.team321.robot.Robot;
import org.usfirst.frc.team321.subsystems.DriveTrain;


import edu.wpi.first.wpilibj.command.Command;


public class MoveStraightForward extends Command {


    DriveTrain drivetrain;
    double rightPower, leftPower;
    double distanceInCm;
    double encoderRotation;
    double time;
    long startTime;
    boolean leftFinished, rightFinished;
    
    double kP = 0, kD = 0;
    double lastError = 0;
    /**
     * Moves forward a specified distance
     * @param distance Distance to go in cm
     * @param power How fast should the robot move
     * @param time How long to move in seconds
     */
    public MoveStraightForward(double distance, double power, double time) {
    	drivetrain = new DriveTrain();
    	requires(Robot.driveTrain);
    	this.distanceInCm = distance;
    	this.leftPower = power;
    	this.rightPower = power;
    	this.time = time;
    }


    @Override
    protected void initialize() {
    	drivetrain.clearEncoder();
    	startTime = System.currentTimeMillis();
    	encoderRotation = Math.abs(drivetrain.distanceToEncDegrees(distanceInCm));
    }


    @Override
    protected void execute() {
    	
    	double error = drivetrain.getLeftSpeedInRPM() - drivetrain.getRightSpeedInRPM();
    	rightPower += kP * error;
    	leftPower += kD * lastError;
    	
    	lastError = error;
    	
    	drivetrain.setMotorPower(leftPower, rightPower);
    	
    	if(time != 0 && System.currentTimeMillis() - startTime > time){
    		drivetrain.stopMotor();
    	}
    }


    @Override
    protected boolean isFinished() {
    	leftFinished =  Math.abs(drivetrain.getLeftEncoderValue()) > encoderRotation;
    	rightFinished = Math.abs(drivetrain.getRightEncoderValue()) > encoderRotation;
    	return leftFinished || rightFinished;
    }


    @Override
    protected void end() {
    	Robot.driveTrain.stopMotor();
    }


    @Override
    protected void interrupted() {
    	Robot.driveTrain.stopMotor();
    }


}
